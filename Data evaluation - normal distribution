This script has data evaluation code that includes data normality distribution, tramsforamtions and scaling 

# Load necessary libraries
library(Cardinal)
library(viridis)
library(openxlsx) # Load the library for Excel output
library(ggplot2)

# Load the file
path_processed <- "/Users/unek/Desktop/gin8_positive.imzml"
print(path_processed)

# Read processed imzML file
msa_peaks <- readMSIData(path_processed)
msa <- msa_peaks

# Data pre-processing 
msa_pre <- reduceBaseline(msa, method="locmin")
process(msa_pre)
msa_peaks <- peakPick(msa_pre, method="mad", SNR=3)
process(msa_peaks)
mse_peaks <- peakAlign(msa_peaks, tolerance=5, units="ppm")
mse <- mse_peaks

# Optional - Data pre-processing step 
mse_filt <- subsetFeatures(mse_peaks, freq > 0.1)
fData(mse_filt)
mse <- mse_filt

# 1. Extract Intensity Distribution Across All Pixels

# This creates a histogram of total ion intensities per pixel to assess signal uniformity
intensities <- colSums(intensity(mse))  # Sum intensities across all m/z values for each pixel
intensity_hist <- ggplot(data.frame(Intensity = intensities), aes(x = Intensity)) +
  geom_histogram(bins = 50, fill = "skyblue", color = "black", alpha = 0.7) +
  labs(title = "Histogram of Total Ion Intensities per Pixel",
       x = "Total Intensity",
       y = "Frequency") +
  theme_minimal() +
  scale_fill_viridis(discrete = FALSE, option = "D")  # Optional: Use viridis for color scale
print(intensity_hist)

# Apply log transformation
log_intensities <- log10(intensities + min(intensities[intensities > 0]))  # Use min non-zero intensity
log_intensity_hist <- ggplot(data.frame(LogIntensity = log_intensities), aes(x = LogIntensity)) +
  geom_histogram(bins = 50, fill = "skyblue", color = "black", alpha = 0.7) +
  labs(title = "Histogram of Log-Transformed Total Ion Intensities per Pixel",
       x = "Log10(Total Intensity)",
       y = "Frequency") +
  theme_minimal()
print(log_intensity_hist)

# Apply Pareto Scaling to Log-Transformed Intensities
# Pareto scaling divides each value by the square root of the standard deviation
sd_log <- sd(log_intensities)
pareto_log_intensities <- log_intensities / sqrt(sd_log)

# 2. Create Histogram of Pareto-Scaled Log-Transformed Intensities
pareto_hist <- ggplot(data.frame(ParetoIntensity = pareto_log_intensities), aes(x = ParetoIntensity)) +
  geom_histogram(bins = 50, fill = "skyblue", color = "black", alpha = 0.7) +
  labs(title = "Histogram of Pareto-Scaled Log-Transformed Total Ion Intensities per Pixel",
       x = "Pareto-Scaled Log10(Total Intensity)",
       y = "Frequency") +
  theme_minimal()
print(pareto_hist)# 2. Save the Plot
ggsave("intensity_histogram.png", intensity_hist, width = 10, height = 6, dpi = 300)


# Apply Autoscaling (Z-Score Scaling) to Log-Transformed Intensities
# Autoscaling standardizes data to have a mean of 0 and standard deviation of 1
auto_log_intensities <- (log_intensities - mean(log_intensities)) / sd(log_intensities)

# Create Histogram of Autoscaled Log-Transformed Intensities
auto_hist <- ggplot(data.frame(AutoIntensity = auto_log_intensities), aes(x = AutoIntensity)) +
  geom_histogram(bins = 50, fill = "salmon", color = "black", alpha = 0.7) +
  labs(title = "Histogram of Autoscaled Log-Transformed Total Ion Intensities per Pixel",
       x = "Autoscaled Log10(Total Intensity)",
       y = "Frequency") +
  theme_minimal()
print(auto_hist)

# Note: Adjust bin sizes, colors, or themes as needed for better visualization. Each bin represents a range of intensity values. 
